# Wand Duel — дуэль жестов

Полноценное приложение для дуэлей волшебников: вы создаёте комнату, выбираете роль (игрок или зритель), рисуете жесты заклинаний на холсте, сервер распознаёт их, а очки начисляются по правилам точности и времени. Клиент написан на React и собирается Vite, сервер — Express + WebSocket, общая логика распознавания и схемы данных вынесены в `shared/`.

Текущая версия: 0.4.2

## Быстрый старт
- Требования: `Node.js >= 18`, `npm`.
- Установка зависимостей: `npm install`
- Режим разработки (Vite в middleware и hot reload): `npm run dev`
- Продакшен-сборка: `npm run build`
- Запуск собранного сервера: `npm start`

По умолчанию сервер слушает порт из переменной окружения `PORT` (если не задан — `5000`). Приложение (клиент и API) доступно по адресу `http://localhost:<PORT>/`.

## Переменные окружения
- `PORT` — порт HTTP-сервера (по умолчанию `5000`).
- `DATABASE_URL` — строка подключения к PostgreSQL. Если не задана, используется хранилище в памяти.
- `FORCE_MEMORY_STORAGE` — если `"true"`, принудительно использовать память даже при наличии `DATABASE_URL`.

## Что нового в 0.4.2
- Тай-брейк по времени: если точность атаки и защиты равна в одном раунде, 1 очко получает тот, кто выполнил свой жест быстрее по времени.
- Абсолютная ничья → бонусный раунд: если и точность, и время равны, запускается серия бонусных раундов до появления победителя.
- Порог успешности: `ATTACK_SUCCESS_THRESHOLD = 50%`, `COUNTER_SUCCESS_THRESHOLD = 52%` (см. `shared/config.ts`).
- Серверная синхронизация таймера раунда: `roundStartTime`, `timeLimit`, `currentPlayerTurn` в `game_sessions`, клиент синхронизируется с серверным временем.
- Улучшенное распознавание жестов: используется расширенный алгоритм (нормализация, сравнение по точкам, линиям и углам) из `shared/advanced-gesture-recognition.ts`.

## Архитектура репозитория
- `client/` — клиент на React (маршрутизация через `wouter`, React Query для данных, Radix UI для компонентов).
- `server/` — сервер на Express, маршруты REST + WebSocket (`/ws`), инициализация данных и работа со storage.
- `shared/` — общие константы, схемы данных (Drizzle ORM) и алгоритм распознавания жестов.
- `dist/` — результат сборки (`dist/public` — статические файлы клиента, `dist/index.js` — бандл сервера).

## Потоки данных и реальное время
- Клиент запрашивает данные через REST API (`fetch`/React Query), а обновления получает через WebSocket.
- Сервер поднимает WebSocket на пути `ws://<host>/ws` и рассылает события `session_update` (например, `round_completed`, `gesture_recognized`, `player_joined`).
- В клиенте хук `client/src/hooks/use-websocket.ts` подключается к `/ws`, отправляет `join_session` c `sessionId` и реагирует на события, инвалидируя нужные запросы React Query.

## Основной сценарий использования
1. Откройте главную страницу. Создайте комнату, указав имя и факультет, или присоединитесь к существующей комнате, введя `roomId`.
2. На странице выбора роли войдите как Игрок (1 или 2) или Зритель; выберите факультет.
3. На арене:
   - Атакующий рисует жест выбранного заклинания на холсте.
   - Сервер сравнивает жест с шаблонами заклинаний и возвращает результат распознавания.
   - Затем защитник рисует контр-жест.
   - После обоих попыток сервер подводит итог раунда и начисляет очки.

## Правила игры и начисление очков
- Количество обычных раундов: `TOTAL_ROUNDS = 10` (см. `shared/config.ts`).
- Пороги успешности: атака — `50%`, защита — `52%`. Попытки с меньшей точностью считаются неуспешными.
- Начисление очков: в каждом раунде 1 очко получает игрок с большей точностью (сравниваются точности атаки и защиты).
- Ничья по точности: решается временем выполнения — быстрее нарисовавший получает 1 очко.
- Абсолютная ничья (равны и точность, и время): запускаются бонусные раунды до выявления победителя.
- Бонусные раунды: атакует всегда Игрок 1; количество бонусных раундов не ограничено и серия продолжается, пока не различится либо точность, либо время.
- Паритет ролей в обычных раундах: нечётные раунды — атакует Игрок 1, чётные — атакует Игрок 2.

## Алгоритм распознавания жестов
- Нормализация: ресэмплинг до 64 точек, центрирование по центроиду, масштабирование в единичный квадрат.
- Сравнение: комбинируется похожесть по точкам (циклическое и обратное выравнивание), по линиям (расстояние точки до отрезка) и по углам поворота траектории; итоговая точность — взвешенная комбинация этих метрик.
- Проверка валидности: отсекаются «каракули» по площади и длине пути (для почти прямых линий — отдельный критерий минимальной длины).
- Имплементация: `shared/advanced-gesture-recognition.ts`; сервер использует `evaluateDrawing(...)` при подсчёте точности.

## Инициализация заклинаний
- На старте сервер вызывает `server/init-spells.ts` и заполняет/обновляет базу из предопределённого набора жестов (около 27 заклинаний).
- Если количество не совпадает с ожидаемым, сервер очищает заклинания и связанные попытки и переинициализирует их.

## Хранилище данных
- В памяти (`MemStorage`) — простой Map-стор, подходит для локальной разработки.
- PostgreSQL (`PostgresStorage`) — при наличии `DATABASE_URL`; миграции выполняются через Drizzle (`npm run db:push`).
- Схемы таблиц: `shared/schema.ts`:
  - `spells` — заклинания и их шаблоны жестов.
  - `game_rooms` — комнаты.
  - `game_sessions` — сессии, текущее состояние раундов/фаз, результаты последней попытки и таймер.
  - `session_participants` — участники сессии (игроки/зрители).
  - `gesture_attempts` — сохранённые попытки с точностью и признаком успеха.

## REST API (ключевые маршруты)
- `POST /api/rooms` — создать комнату; возвращает `room` и связанную `session`.
- `GET /api/rooms/:roomId` — получить комнату.
- `GET /api/rooms/:roomId/session` — получить сессию комнаты.
- `POST /api/sessions/:sessionId/join` — присоединиться к сессии как игрок или зритель (с выбором факультета).
- `GET /api/sessions/:id` — текущее состояние сессии (раунд, фаза, счёт).
- `GET /api/sessions/:sessionId/participants` — список участников.
- `GET /api/sessions/:sessionId/spell-history` — история попыток (с деталями заклинаний).
  - Для каждой попытки дополнительно возвращается `timeSpentSeconds` (секунды, затраченные на рисование).
- `POST /api/sessions/:id/recognize-gesture` — отправка нарисованного жеста для распознавания.
  - Ответ содержит `recognized` (boolean), `accuracy` (0–100), `successful` (boolean), `message` (строка), а также `spell` при успешном сопоставлении.
  - Возможные `message`: «Жест не распознан», «Попробуйте перерисовать жест точнее», «Это заклинание уже было использовано…» и др.
- `POST /api/sessions/:id/complete-round` — завершение раунда и переход к следующему (или бонусному/завершению игры).
- `POST /api/sessions/:id/check-timeout` — проверка тайм-аута фазы по серверному таймеру.

Дополнительно: при `DEBUG_GESTURES=1` сервер выводит подробный разбор совпадений жестов в лог.

## UI и уведомления
- Холст рисования: компонент `GestureCanvas` в `DuelArena`. База заклинаний и превью — `SpellDatabase`, `GesturePreview`.
- Тосты: «Заклинание не опознано» показывается только когда `recognized === false`. Для «Атака уже использована» отображается отдельный тост. Для случаев «распознано, но точность низкая» тост не показывается — это было исправлено в `client/src/pages/duel-arena.tsx` внутри обработчика `onSuccess` мутации распознавания.

## Таймеры и синхронизация
- Сервер хранит `roundStartTime`, `timeLimit` и `currentPlayerTurn` в таблице `game_sessions`.
- Клиент периодически синхронизирует время и считает оставшееся время фазы; при истечении времени сервер завершает раунд (в защитной фазе победное очко получает защитник по логике тайм-аута).
- Отдельные попытки сохраняют `timeSpentSeconds` и используются для тай-брейка по времени.

## Сборка и развёртывание
- Клиент: Vite собирает статику в `dist/public`.
- Сервер: `esbuild` собирает `server/index.ts` в `dist/index.js` (ESM, внешние пакеты не бандлятся).
- В продакшене сервер раздаёт статику из `dist/public` (см. `server/vite.ts::serveStatic`). В разработке используется Vite middleware (`server/vite.ts::setupVite`).

## Тесты и отладка распознавания
- Быстрый прогон алгоритма: запустите `shared/gesture-recognition.test.ts` (содержит простые сценарии для оценки `evaluateDrawing`).
- Для генерации новых шаблонов жестов можно сериализовать координаты из холста и добавлять их в `init-spells.ts`.

## Траблшутинг
- WebSocket не подключается:
  - Убедитесь, что открываете именно `http://localhost:<PORT>/` и сервер запущен.
  - Проверьте, что брандмауэр не блокирует порт `PORT`.
- База данных:
  - Если нет PostgreSQL, просто не задавайте `DATABASE_URL` — всё будет работать в памяти.
  - При переходе на БД выполните `npm run db:push` для применения схем.
- Точность распознавания слишком низкая:
  - Проверьте валидность рисунка (движение должно иметь площадь и длину пути).
  - Пороговые значения находятся в `shared/config.ts` и могут быть откалиброваны.

## Структура ключевых файлов
- `client/src/pages/room-lobby.tsx` — создание/вход в комнату.
- `client/src/pages/role-selection.tsx` — выбор роли и факультета.
- `client/src/pages/duel-arena.tsx` — основная логика дуэли, рисование жестов, тосты, диалоги.
- `server/index.ts` — запуск сервера, выбор хранилища, настройка Vite/статической выдачи и WebSocket.
- `server/routes.ts` — все REST-маршруты и логика раундов/счёта.
- `server/websocket.ts` — сервер WebSocket и широковещательные события.
- `server/init-spells.ts` — начальные заклинания и обновление шаблонов.
- `shared/advanced-gesture-recognition.ts` — нормализация, сравнение и оценка жеста.
- `shared/schema.ts` — схемы таблиц и типы.
- `shared/config.ts` — пороги и настройки игры.

Готово. Если нужен английский README или скриншоты — скажите, добавлю.